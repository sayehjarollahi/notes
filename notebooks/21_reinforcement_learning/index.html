---
layout: content
metadata: notebooks_21_reinforcement_learning_metadata
---
<h1>Reinforcement Learning</h1>
<h1>Table of content</h1>
<ul>
<li><a href="#introduction">Introduction</a> </li>
<li><a href="#OnlinevsOfflineLearning">Online vs Offline Learning</a></li>
<li><a href="#MainElementsofRL">Main Elements of RL</a></li>
<li><a href="#DifferentMethodsofLearningAccordingtoModel">Different Methods of Learning According to Model</a><ul>
<li><a href="#Model-basedRL">Model-based RL</a></li>
<li><a href="#Model-freeRL">Model-free RL</a><ul>
<li><a href="#anexample1">an example</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#TypesofReinforcementLearningAccordingtoLearningPolicy">Types of Reinforcement Learning According to Learning Policy</a><ul>
<li><a href="#PassiveReinforcementLearning">Passive Reinforcement Learning</a></li>
<li><a href="#ActiveReinforcementLearning">Active Reinforcement Learning</a></li>
</ul>
</li>
<li><a href="#PolicyEvaluation">Policy Evaluation</a></li>
<li><a href="#DirectUtilityEstimation">Direct Utility Estimation</a><ul>
<li><a href="#Definition">Definition</a><ul>
<li><a href="#anexample2">an example</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#AdvantagesofDirectUtilityEstimation">Advantages of Direct Utility Estimation</a></li>
<li><a href="#DisadvantagesofDirectUtilityEstimation">Disadvantages of Direct Utility Estimation</a></li>
<li><a href="#TemporalDifference(TD)Learning">Temporal Difference (TD) Learning</a><ul>
<li><a href="#DefinitionTD">Definition</a></li>
<li><a href="#pseudocode">pseudocode</a></li>
<li><a href="#SomeaspectsofTD">Some aspects of TD</a></li>
<li><a href="#anexample3">an example</a></li>
</ul>
</li>
<li><a href="#ProblemwithTD">Problem with TD</a></li>
<li><a href="#Conclusion">Summery and Conclusion</a></li>
<li><a href="#usefullinks">Useful Links</a></li>
<li><a href="#resources">References</a></li>
</ul>
<div id="introduction"></div>
<h1>Inroduction</h1>
<p><em><strong>"... What we want is a machine that can learn from experience." -Alan Turing, 1947</strong></em></p>
<p>At the beginning of the lecture note, we briefly introduce the RL algorithm. After that, we compare online models to offline models. Additionally, we compare different categories of learning methods based on the model. Then we use Direct Utility Estimation Method to estimate our factor based on sample values. Later, we introduce Temporal Difference Learning Algorithm to understand how the agent can gain experience and learn from the envirnment if it does not have enough knowledge. At the end of the discussion, there is a summary of different topics in RL which we have learned. </p>
<p><strong>Reinforcement Learning</strong> is a subcategory of Machine Learning which can solve real-life problems. These problems involve learning what to do—how to
map situations to actions— to maximize a numerical reward signal. In this learning system, the system's actions influence its later inputs. Moreover, the learner is not told which actions to take but instead must discover
which actions yield the most reward by trying them out.
<br/></p>
<div style="text-align:center">
<img src="/notes/assets/resources/agent.jpg"/>
<br/>
<em>relation of agent and environment</em>
</div>
<p><br/></p>
<div id="OnlinevsOfflineLearning"></div>
<h2>Online vs Offline Learning</h2>
<p>Overall, there are two learning methods—online and offline. In the online approach, the agent has no information about the environment. It gathers information by rewards and decides which states are good and which are bad and should be avoided. However, in the offline method, the agent has prior information, helping it decide on its actions based on the information and receive a less negative reward.
Reinforcement learning (RL) is an MDP without $T$ and $R$, meaning it has no information on the environment. Thus, the learning method in RL is online.</p>
<div style="text-align:center">
<img src="/notes/assets/resources/online.jpg"/>
<br/>
</div>
<p><br/></p>
<div id="MainElementsofRL"></div>
<h2>Main Elements of RL</h2>
<ol>
<li>Policy $\pi : S \rightarrow A$<ul>
<li>It is a map from state space to action space. </li>
<li>It may be stochastic.</li>
</ul>
</li>
<li>Reward Function R(s)<ul>
<li>It maps each state to a real number, called <strong>reward</strong>.</li>
<li>Agent's utility is defined by the reward function. Agent must learn to maximize expected rewards. </li>
</ul>
</li>
<li>Value Function V(s)<ul>
<li>The value of a state is the total expected reward starting from that state. </li>
</ul>
</li>
</ol>
<p><br/></p>
<div id="DifferentMethodsofLearningAccordingtoModel"></div>
<h2>Different Methods of Learning According to Model</h2>
<p>RL systems can be divided into two categories: <strong>model-based</strong> and <strong>model-free</strong></p>
<div id="Model-basedRL"></div>
<ul>
<li>
<p><strong>Model-based RL :</strong>  This method tries to overcome the issue of a lack of prior knowledge to construct a functional representation of its environment. It solves the problem in two steps:</p>
<ol>
<li>
<p><strong>Learn imprical MDP model :</strong> In this model, the agent explores the environment and performs some actions to estimate the parameters of the model. These parameters are  $\hat{T}(s, a, s')$ and $\hat{R}(s, a, s')$. First, it counts outcomes $s'$ for each $s,a$. Second, it normalizes the values to give an estimate of $\hat{T}(s,a,s')$. At last, it discovers each $\hat{R}(s,a,s')$ when it experiences $(s, a, s')$.</p>
</li>
<li>
<p><strong>Solve the learned MDP:</strong> After estimating the missing parameters of the MDP model, the agent can solve the MDP by using various algorithms (e.g. <em>Value Iteration</em>) that are mentioned before. </p>
</li>
</ol>
</li>
</ul>
<div id="Model-freeRL"></div>
<ul>
<li><strong>Model-free RL:</strong> Unlike the previous category, in this type of Reinforcement Learning, the parameters of the traditional MDP are not estimated.  Consequently, the agent directly learns the policy and the evaluation function. This algorithm can be thought of as a <em>trial and error</em> algorithm. </li>
</ul>
<p><br/></p>
<div id="anexample1"></div>
<p><strong>Example:</strong> Assume that an agent wants to compute the expected age of students in one class. ($A$ is a random variable that represents the distribution of age) If the agent has the distribution of $A$, it can easily calculate the expectation according to $E[A] = \sum_{a} P(a).a$ . On the other hand, if the agent doesn't have the distribution over $A$, the problem must use Reinforcement Learning that can be solved with model-based or model-free RL. 
<br/>
* <strong>Model-based approach:</strong> In this algorithm, first we have to estimate $\hat{P}(a)$. The estimation is simple in this special example, but it can be complicated in real-world problems. We start exploring and getting samples and then We set $\hat{P}(a) = \frac{num(a)}{N}$. $num(a)$ is the number of occurrences of the age $a$. Finally, after finding the probability function, we can find the expectation with $E[A] \approx \sum_{a} \hat{P}(a).a$.
<br/>
* <strong>Model-free approach:</strong> In this algorithm, there is no need to find $\hat{P}(a)$. After exploring the envirnoment and gathering samples, we can directly calculate the value of $E[A] = \frac{1}{N}\sum_{i} a_i$. Samples appear with accurate frequencies. As a result, we can be sure that this algorithm works efficiently. </p>
<p><strong>Example:</strong> In this example, we are going to estimate $\hat{T}(s,a,s')$ and $\hat{R}(s,a,s')$ using model-based RL. In these kinds of questions, we need to fix the input policy $(\pi)$ and observe episodes to train the model and estimate the parameters. Each episode contains a series of movements with the same length (in this example the length of each episode is 3). After observing, we can estimate the possibility of each transition and the reward function for each movement. </p>
<p><img align="left" src="/notes/assets/resources/modelbased.png" width="315px"/></p>
<table>
<thead>
<tr>
<th></th>
<th>     Episode1             Episode2     </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><table> <tbody> <td>B</td> <td>east</td> <td>C</td> <td>-1</td> <td>     B</td> <td> east</td> <td> C</td> <td> -1</td> </tbody></table></td></tr> <tr> <td>C</td> <td>east</td> <td>D</td><td>-1</td> <td>     C</td> <td> east</td> <td> D</td> <td> -1</td> </tr> <tr> <td>D</td> <td>exit</td> <td>X</td><td>+10</td> <td>     D</td> <td> exit</td> <td> X</td> <td> +10</td> </tr> <tr> </tr></tbody> </table>



<table>
<thead>
<tr>
<th></th>
<th>     Episode3             Episode4     </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><table> <tbody> <td>E</td> <td>north</td> <td>C</td> <td>-1</td> <td>     E</td> <td>north</td> <td>C</td> <td>-1</td> </tbody></table></td></tr> <tr> <td>C</td> <td>east</td> <td>D</td><td>-1</td> <td>     C</td> <td> east</td> <td> A</td> <td> -1</td> </tr> <tr> <td>D</td> <td>exit</td> <td>X</td><td>+10</td> <td>     A</td> <td> exit</td> <td> X</td> <td> +10</td> </tr> <tr> </tr></tbody> </table>



<p><br clear="left">
<br/></br></p>
<p>After sampling, in order to estimate $\hat{T}$ for each $(s,a,s')$, we have to count the number of all movements that start from $s$ and have the action $a$ and go to state $s'$. After that we have to divise this count to the number of movements that start from $s$ and have the action $a$. For example:
* $T(B, east, C) = \frac{2}{2} = 1$
* $T(C, east, D) = \frac{3}{4} = 0.75$
<br/>
In addition, we can estimate $\hat{R}(s,a,s')$ for each movement in all episodes. We have to get the average of the reward for all tuples of $(s,a,s')$. For example:
<br/>
* $$R(B, east, C) = \frac{-1-1}{2} = -1$$
* $$R(D, exit, x) = \frac{10+10+10}{3} = 10$$</p>
<p><strong>Question:</strong> What is the problem of above model-based algorithm?<br/> If the number of states are large, the number of required samples to train the model will be $O((|S|)^2.|A|)$. In other words, we need many episodes to be able to train the model properly. </p>
<div id="TypesofReinforcementLearningAccordingtoLearningPolicy"></div>
<h2>Types of Reinforcement Learning According to Learning Policy</h2>
<p>According to learning policy, there are two types of RL: <strong>Passive Reinforcement Learning</strong>, <strong>Active Reinforcement Learning</strong>. In below, we explain both methods.</p>
<div id="PassiveReinforcementLearning"></div>
<h2>Passive Reinforcement Learning</h2>
<p>Passive reinforcement learning is when we want an agent to learn about the utilities of various states under a fixed policy. The learned policy will be different from the original fixed policy. <em><strong>Direct Utility Estimation</strong></em> and <em><strong>Temporal Difference Learning</strong></em> are two passive RL algorithms. </p>
<div id="ActiveReinforcementLearning"></div>
<h2>Active Reinforcement Learning</h2>
<p>Active reinforcement learning is when the agent's policy is not fixed and can change during the time of training. In this method exploration and exploition are done. Exploration refers to trying new actions that are rarely done and checking if they have a bigger reward. Exploition refers to keep doing the optimal action at each state. <em>Q-learning</em> is one of the active RL algorithms. </p>
<div id="PolicyEvaluation"></div>
<h2>Policy Evaluation</h2>
<p>Policy evaluation computes the value functions for a policy $\pi$ using the Bellman equations.
$$ V^{\pi}<em k_1="k+1">0 (s) = 0 $$
$$ V^{\pi}</em> \leftarrow \sum_{s'}T(s, \pi(s), s')[R(s, \pi, s') + \gamma V^{\pi}_k(s') $$
In fact, simplified Bellman updates calculate V for a fixed policy:
* Each round, replace V with a one-step-look-ahead layer over V
* This approach fully exploited the connections between the states</p>
<div id="DirectUtilityEstimation"></div>
<h1>Direct Utility Estimation</h1>
<div id="Definition"></div>
<p><strong>Definition:</strong> In this method, the agent executes a sequence of trials. Each trial gives a sample value and the agent estimates the utility based on the samples values. This can be calculated as running averages of sample values.</p>
<ul>
<li>
<p><strong>Direct utility estimation (model-free)</strong></p>
<ul>
<li>Estimate <strong>$V^{\pi}(s)$</strong> as the average total reward of epochs containing $s$ (calculating from $s$ to end of epoch)</li>
</ul>
</li>
<li>
<p><strong>Reward-to-go of a state</strong> <strong>$s$</strong></p>
<ul>
<li>The sum of the (discounted)rewards from that state until a  terminal state is reached</li>
</ul>
</li>
<li>
<p><strong>Key</strong>: use observed reward-to-go of the state as the direct evidence of the actual expected utility of that state</p>
</li>
</ul>
<p>Suppose we have a 4x3 grid as the environment in which the agent can move either Left, Right, Up or Down(set of available actions). An example of a run:</p>
<p>$(1,1) <em -0.04="-0.04">{-0.04}  \rightarrow (1,2) </em>  \rightarrow (1,3) <em -0.04="-0.04">{-0.04}  \rightarrow (1,2) </em>  \rightarrow (1,3) <em -0.04="-0.04">{-0.04}  \rightarrow (2,3) </em>  \rightarrow (3,3) <em _1="+1">{-0.04} \rightarrow (4,3) </em>$   </p>
<p>The total reward starting at (1,1) is 0.72. We call this a sample of the observed-reward-to-go for (1,1).</p>
<p>For (1,2) there are two samples for the observed-reward-to-go (assuming $\gamma$=1):</p>
<ol>
<li>
<p>$(1,2) <em -0.04="-0.04">{-0.04}\rightarrow (1,3) </em>\rightarrow (1,2) <em -0.04="-0.04">{-0.04}  \rightarrow (1,3) </em>  \rightarrow (2,3) <em -0.04="-0.04">{-0.04}  \rightarrow (3,3) </em>  \rightarrow (4,3) _{+1}     [Total:0.76] $ </p>
</li>
<li>
<p>$(1,2) <em -0.04="-0.04">{-0.04}  \rightarrow (1,3) </em>  \rightarrow (2,3) <em -0.04="-0.04">{-0.04}  \rightarrow (3,3) </em>  \rightarrow (4,3) _{+1}    [Total:0.84]$</p>
</li>
<li>
<p>Direct Utility Estimation keeps a running average of this observed reward-to-go for each state</p>
</li>
<li>
<p>Eg. for state (1,2), it stores $\frac{(0.76+0.84)}{2}=0.8$</p>
</li>
</ol>
<p>Thus, at the end of each sequence, the algorithm calculates the observed reward-to-go for each state and updates the estimated utility for that state accordingly, just by keeping a running average for each state in a table. In the limit of infinitely many trials, the sample average will converge to the true expectation in the following Equation.</p>
<p>    <strong>$V^\pi (s) = E [\sum_{t = 0}^{\infty } \gamma^t R (S_{t})]$</strong></p>
<p>Direct utility estimation succeeds in reducing the reinforcement learning problem to an inductive learning problem, about which much is known. Unfortunately, it misses a very important source of information, namely, the fact that the utilities of states are not independent! The utility of each state equals its own reward plus the expected utility of its successor states. That is, the utility values obey the Bellman equations for a fixed policy (the following  Equation)</p>
<p>   <strong>$V^\pi (s) =R(S)+\gamma \sum_{\acute{s}}   P(\acute{s}|s,\pi(s))   U^\pi(\acute{s})$</strong></p>
<p><br>
<br/></br></p>
<p>And now it is good to see an example. The purpose of this question is to estimate the returns.</p>
<div id="anexample2"></div>
<p><strong>Example:</strong> Calculate the return of each state according to the figure below and the given episodes.($\gamma =1$)</p>
<p><img align="left" src="/notes/assets/resources/one.PNG" width="315px"/></p>
<table>
<thead>
<tr>
<th></th>
<th>     Episode1             Episode2     </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><table> <tbody> <td>B</td> <td>east</td> <td>C</td> <td>-1</td> <td>     B</td> <td> east</td> <td> C</td> <td> -1</td> </tbody></table></td></tr> <tr> <td>C</td> <td>east</td> <td>D</td><td>-1</td> <td>     C</td> <td> east</td> <td> D</td> <td> -1</td> </tr> <tr> <td>D</td> <td>exit</td> <td>X</td><td>+10</td> <td>     D</td> <td> exit</td> <td> X</td> <td> +10</td> </tr> <tr> </tr></tbody> </table>



<table>
<thead>
<tr>
<th></th>
<th>     Episode3             Episode4     </th>
</tr>
</thead>
<tbody>
<tr>
<td></td>
<td><table> <tbody> <td>E</td> <td>north</td> <td>C</td> <td>-1</td> <td>     E</td> <td>north</td> <td>C</td> <td>-1</td> </tbody></table></td></tr> <tr> <td>C</td> <td>east</td> <td>D</td><td>-1</td> <td>     C</td> <td> east</td> <td> A</td> <td> -1</td> </tr> <tr> <td>D</td> <td>exit</td> <td>X</td><td>+10</td> <td>     A</td> <td> exit</td> <td> X</td> <td> +10</td> </tr> <tr> </tr></tbody> </table>



<p><br clear="left"/></p>
<p><br>
<br/></br></p>
<p>Now we solve this example:</p>
<p><img align="left" src="/notes/assets/resources/two.PNG" width="320px"/>  </p>
<p><br><br><br><br><br><br><br><br/><br/><br/><br/><br/><br/></br></br></br></br></br></br></br></p>
<p><br/>According to the question, you have to estimate the return seen in each state.</p>
<p>According to the given episodes and $\gamma = 1$, you should look for your state in the first column of each episode, then average the numbers(s) in the last column, from that point until the end.</p>
<p>Pay attention to the solution:</p>
<p><strong>state A:</strong>   You can see A just in the fourth episode $\rightarrow$ $\frac{(+10)}{1}=+10$ </p>
<p><strong>state B:</strong>  You can see B in the first and second episodes $\rightarrow$
$\frac{( -1  -1 + 10) + ( -1 -1 + 10 ) }{ 2} = +8$
<br/></p>
<p><strong>state C:</strong>   You can see C in all episodes $\rightarrow$
$\frac{( -1 + 10 )+( -1+10 ) + ( -1 + 10 )+( -1 -10 )} {4} = +4$</p>
<p><strong>state D:</strong>   You can see D in The first three states $\rightarrow$  
$\frac{(+10+10+10)}{3} =+10$</p>
<p>If you pay more attention, you will notice that the problem with this method is, we can move to C both from E and B, but we find very different values for them. The reason for this difference is the lack of sample. we also express the values of each state independent from other states.
<br/><br/></p>
<div id="AdvantagesofDirectUtilityEstimation"></div>
<h2>Advantages of Direct Utility Estimation</h2>
<ul>
<li>
<p>Easy to understand</p>
</li>
<li>
<p>Does not require any knowledge of T, R </p>
</li>
<li>
<p>Computes the correct average values, using just sample transitions</p>
</li>
</ul>
<p><br/></p>
<div id="DisadvantagesofDirectUtilityEstimation"></div>
<h2>Disadvantages of Direct Utility Estimation</h2>
<ul>
<li>
<p>Wastes information about state connections </p>
</li>
<li>
<p>Each state must be learned separately </p>
</li>
<li>
<p>Takes a long time to learn</p>
</li>
<li>
<p>Converges very slowly</p>
</li>
</ul>
<p>        Why?</p>
<p>          <strong>-</strong> Does not exploit the fact that utilities of states are not independent </p>
<p>          <strong>-</strong> Utilities follow the Bellman equation</p>
<p>                $V_{\pi} (s) =R(S)+\gamma \sum_{\acute{s}} T(s,\pi(s),{\acute{s}})V_{\pi}({\acute{s}})$</p>
<p><strong>Question</strong>: How to approximate E[X] (The right side of the equation below) based on model-free learning?</p>
<p>$V^\pi_{k+1}(s) \leftarrow \sum_{{\acute{s}}} T(s,\pi(s),\acute{s} )[R(s,\pi(s),\acute{s} )+\gamma V^\pi_{k} ]$</p>
<p>We cannot use this equation directly since we do not have T and R, but we can use the average of the returned value ($[R(s,\pi(s),\acute{s} )+\gamma V^\pi_{k} ]$). 
So we can change our formula to the following form.</p>
<p>$V^\pi (s) \approx \frac{1}{N} \sum [R(s,\pi(s),\acute{s})+\gamma  V^\pi(\acute{s})]$</p>
<p>If you pay a little attention, you will notice that there is a problem, so what is the problem with this approach? In one state, an action cannot be repeated N times, because you move on to another state as soon as an action is taken and it will be physically impossible be able to perform another action in the same state. Now, what is the solution?</p>
<p>You can take the average in more than one shot, for example, take different actions in multiple episodes and update the average as you arrive to the desired state.
For example, if the average is $\varphi$ up to this point, the updated average would be:</p>
<p>$\varphi_{new} = \varphi n + \frac {x} {n+1}$</p>
<p>In which $n$ is the number of data you have collected.</p>
<div id="TemporalDifference(TD)Learning"></div>
<h1>Temporal Difference (TD) Learning</h1>
<div id="DefinitionTD"></div>
<p><strong>Definition:</strong> TD is an agent learning from an environment through episodes with no prior knowledge of the environment.</p>
<ul>
<li>
<p>It learns from trial and error.</p>
</li>
<li>
<p>TD takes a model-free or unsupervised learning approach.</p>
</li>
<li>
<p>TD tries to predict the immediate reward and the reward at the next moment instead of calculating the total future reward.</p>
</li>
</ul>
<p>The key concept of the a TD agent: ($R$ is the reward function)</p>
<p>$$R_{t} = r_{t+1} + \gamma r_{t+2} + \gamma ^{2} r_{t+3} + ... = \sum_{k = 0}^{\infty }\gamma ^{k} r_{t + k + 1}$$</p>
<p>In fact, TD learning tries to answer the question of how to compute this weighted average without the weights, cleverly doing so with an exponential
moving average. In this equation reward at time <strong>t</strong> is a combination of discounted rewards in the future which shows that future rewards are valued less.</p>
<p>TD agent error:</p>
<p>$$ E_{t} = V^{\pi ^ *}<em t="t">{t} - V^\pi</em> $$\
$$= r_{t+1} + \sum_{k = 1}^{\infty }\gamma ^{k} r_{t + k + 1} - V^ \pi_{t} $$\
$$= r_{t+1} + \gamma \times \sum_{k = 1}^{\infty }\gamma ^{k-1} r_{t + k + 1} - V^\pi_{t} $$\
$$= r_{t+1} + \gamma \times \sum_{k = 0}^{\infty }\gamma ^{k} r_{(t  + 1) + (k + 1)} - V^\pi_{t}$$\
$$=  r_{t+1} + \gamma \times \sum_{k = 0}^{\infty }\gamma ^{k} r_{(t  + 1) + (k + 1)} - V^\pi_{t}$$\
$$= r_{t+1} + \gamma \times V^\pi_{t+1} - V^\pi_{t}$$</p>
<p>Updating the value: ($\alpha$ is learning rate)</p>
<p>$$V^\pi_{t} \leftarrow V^\pi_{t} + \alpha \times E_{t} = V^\pi_{t} + \alpha \times( r_{t+1} + \gamma \times V^\pi_{t+1} - V^\pi_{t})$$</p>
<div id="pseudocode"></div>
<h2>Pseudocode</h2>
<p>The pseudocode of the process is shown below.</p>
<div class="codehilite"><pre><span></span><code><span class="k">function</span><span class="w"> </span><span class="nf">PASSIVE-TD-AGENT</span><span class="p">(</span>percept<span class="p">)</span><span class="w"> </span><span class="n">returns</span><span class="w"> </span><span class="n">an</span><span class="w"> </span><span class="n">action</span><span class="w"></span>
<span class="w">    </span><span class="n">inputs</span><span class="p">:</span><span class="w"> </span><span class="n">percept</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">percept</span><span class="w"> </span><span class="n">indicating</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">current</span><span class="w"> </span><span class="n">state</span><span class="w"> </span><span class="n">s</span><span class="o">'</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">rewarl</span><span class="w"> </span><span class="n">signal</span><span class="w"> </span><span class="n">r</span><span class="o">'</span><span class="w"></span>
<span class="w">    </span><span class="k">persistent</span><span class="p">:</span><span class="w"> </span><span class="nb">pi</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">fixed</span><span class="w"> </span><span class="n">policy</span><span class="w"></span>
<span class="w">                </span><span class="n">V</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="nb">table</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="nb">values</span><span class="p">(</span><span class="n">utilities</span><span class="p">),</span><span class="w"> </span><span class="n">initially</span><span class="w"> </span><span class="nb">empty</span><span class="w"></span>
<span class="w">                </span><span class="n">N_</span><span class="p">{</span><span class="n">s</span><span class="p">},</span><span class="w"> </span><span class="n">a</span><span class="w"> </span><span class="n">of</span><span class="w"> </span><span class="n">frequencies</span><span class="w"> </span><span class="k">for</span><span class="w"> </span><span class="n">states</span><span class="p">,</span><span class="w"> </span><span class="n">initially</span><span class="w"> </span><span class="n">zero</span><span class="w"></span>
<span class="w">                </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="p">,</span><span class="w"> </span><span class="n">the</span><span class="w"> </span><span class="n">previous</span><span class="w"> </span><span class="n">state</span><span class="p">,</span><span class="w"> </span><span class="n">action</span><span class="p">,</span><span class="w"> </span><span class="n">and</span><span class="w"> </span><span class="n">reward</span><span class="p">,</span><span class="w"> </span><span class="n">initially</span><span class="w"> </span><span class="nb">null</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">s</span><span class="o">'</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">new</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">V</span><span class="p">[</span><span class="n">s</span><span class="o">'</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">r</span><span class="o">'</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">s</span><span class="w"> </span><span class="n">is</span><span class="w"> </span><span class="n">not</span><span class="w"> </span><span class="nb">null</span><span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="p">:</span><span class="w"></span>
<span class="w">        </span><span class="n">increment</span><span class="w"> </span><span class="n">N_</span><span class="p">{</span><span class="n">s</span><span class="p">}[</span><span class="n">s</span><span class="p">]</span><span class="w"></span>
<span class="w">        </span><span class="n">V</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">V</span><span class="p">[</span><span class="n">s</span><span class="p">]</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">alpha</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="p">(</span><span class="n">N_</span><span class="p">{</span><span class="n">s</span><span class="p">}[</span><span class="n">s</span><span class="p">])(</span><span class="n">r</span><span class="w"> </span><span class="o">+</span><span class="w"> </span><span class="nb">gamma</span><span class="w"> </span><span class="o">*</span><span class="w"> </span><span class="n">V</span><span class="p">[</span><span class="n">s</span><span class="o">'</span><span class="p">]</span><span class="w"> </span><span class="o">-</span><span class="w"> </span><span class="n">V</span><span class="p">[</span><span class="n">s</span><span class="p">])</span><span class="w"></span>
<span class="w">    </span><span class="k">if</span><span class="w"> </span><span class="n">s</span><span class="o">'</span><span class="p">.</span><span class="n">TERMINAL</span>?<span class="w"> </span><span class="n">then</span><span class="w"> </span><span class="n">s</span><span class="p">,</span><span class="w"> </span><span class="n">a</span><span class="p">,</span><span class="w"> </span><span class="n">r</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">null</span><span class="w"></span>
<span class="w">       </span><span class="k">else</span><span class="w"> </span><span class="p">:</span><span class="w"></span>
<span class="w">           </span><span class="n">s</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">s</span><span class="o">'</span><span class="w"></span>
<span class="w">           </span><span class="n">a</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="nb">pi</span><span class="p">[</span><span class="n">s</span><span class="o">'</span><span class="p">]</span><span class="w"></span>
<span class="w">           </span><span class="n">r</span><span class="w"> </span><span class="p">=</span><span class="w"> </span><span class="n">r</span><span class="o">'</span><span class="w"></span>
<span class="w">    </span><span class="k">return</span><span class="w"> </span><span class="n">a</span><span class="w"></span>
</code></pre></div>
<p>It is good to mention that because rare transitions occur only rarely, the average of <strong>value function</strong> will converge to the correct value.</p>
<div id="SomeaspectsofTD"></div>
<h2>Some aspects of TD</h2>
<ol>
<li>TD shows almost high variability.</li>
<li>TD is a quite simple method in RL.</li>
<li>TD does quite little computation per observation.</li>
<li>TD adjusts a state to be consistent with its <strong>observed</strong> successor states.</li>
<li>TD makes a single adjustment per observation.</li>
<li>TD is a crude but efficient approximation to other methods in RL.</li>
<li>TD does not need a transition model to do the update.</li>
<li>TD uses <strong>exponential moving average</strong> which runs an interpolation and makes recent samples more important in the process. The method forgets about the past. The recursive formula is written below.
$$x_{n} = (1-\alpha) . x_{n-1} + \alpha . x_{n}$$<ul>
<li>In this formula:
    a decreases → converging averages</li>
</ul>
</li>
</ol>
<div id="anexample3"></div>
<p><strong>Example</strong></p>
<p>Consider the following grid with $\gamma = 1$ and $\alpha = 1/2$. We have the initial $V^{\pi}(x_i)$ in State 1. We want to calculate $V^{\pi}(B)$ and $V^{\pi}(C)$ after sampling and two moves.
<br/>
<img src="/notes/assets/resources/1.png" style="width:200px;"/></p>
<table>
<thead>
<tr>
<th align="center">State 1</th>
<th align="center">Move 1(B, east, C, -2)</th>
<th align="center">State 2</th>
<th align="center">Move 2 (C, east, D, -2)</th>
<th align="center">State 3</th>
</tr>
</thead>
<tbody>
<tr>
<td align="center"><img src="/notes/assets/resources/2.png" style="width:200px;"/></td>
<td align="center"></td>
<td align="center"><img src="/notes/assets/resources/3.png" style="width:200px;"/></td>
<td align="center"></td>
<td align="center"><img src="/notes/assets/resources/4.png" style="width:200px;"/></td>
</tr>
</tbody>
</table>
<p>The formula is:
$$V^\pi_{t} \leftarrow V^\pi_{t} + \alpha \times E_{t} = V^\pi_{t} + \alpha \times( r_{t+1} + \gamma \times V^\pi_{t+1} - V^\pi_{t})$$
Calculations:</p>
<p>$V^{\pi}(B) = ?$</p>
<p>$V^{\pi}(B) \leftarrow V^{\pi}(B) + \alpha \times (-2 + \gamma \times V^{\pi}(C))$</p>
<p>$\rightarrow V^{\pi}(B) = 0 + 1/2 \times (-2 + 1 \times 0) = -1$</p>
<p>$V^{\pi}(C) = ?$</p>
<p>$V^{\pi}(C) \leftarrow V^{\pi}(C) + \alpha \times (-2 + \gamma \times V^{\pi}(D))$</p>
<p>$\rightarrow V^{\pi}(C) = 0 + 1/2 \times (-2 + 1 \times 8) = 3$</p>
<p>For better understanding and seeing how a TD agent acts in the environment, see the code below, which belongs to "HalfCheetah-v2", a TD agent.</p>
<div class="codehilite"><pre><span></span><code><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="kn">from</span> <span class="nn">gym</span> <span class="kn">import</span> <span class="n">utils</span>
<span class="kn">from</span> <span class="nn">gym.envs.mujoco</span> <span class="kn">import</span> <span class="n">mujoco_env</span>


<span class="k">class</span> <span class="nc">HalfCheetahEnv</span><span class="p">(</span><span class="n">mujoco_env</span><span class="o">.</span><span class="n">MujocoEnv</span><span class="p">,</span> <span class="n">utils</span><span class="o">.</span><span class="n">EzPickle</span><span class="p">):</span>
    <span class="k">def</span> <span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">mujoco_env</span><span class="o">.</span><span class="n">MujocoEnv</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="s2">"half_cheetah.xml"</span><span class="p">,</span> <span class="mi">5</span><span class="p">)</span>
        <span class="n">utils</span><span class="o">.</span><span class="n">EzPickle</span><span class="o">.</span><span class="fm">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">step</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">action</span><span class="p">):</span>
        <span class="n">xposbefore</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">qpos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">do_simulation</span><span class="p">(</span><span class="n">action</span><span class="p">,</span> <span class="bp">self</span><span class="o">.</span><span class="n">frame_skip</span><span class="p">)</span>
        <span class="n">xposafter</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">qpos</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">ob</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_obs</span><span class="p">()</span>
        <span class="n">reward_ctrl</span> <span class="o">=</span> <span class="o">-</span><span class="mf">0.1</span> <span class="o">*</span> <span class="n">np</span><span class="o">.</span><span class="kp">square</span><span class="p">(</span><span class="n">action</span><span class="p">)</span><span class="o">.</span><span class="kp">sum</span><span class="p">()</span>
        <span class="n">reward_run</span> <span class="o">=</span> <span class="p">(</span><span class="n">xposafter</span> <span class="o">-</span> <span class="n">xposbefore</span><span class="p">)</span> <span class="o">/</span> <span class="bp">self</span><span class="o">.</span><span class="n">dt</span>
        <span class="n">reward</span> <span class="o">=</span> <span class="n">reward_ctrl</span> <span class="o">+</span> <span class="n">reward_run</span>
        <span class="n">done</span> <span class="o">=</span> <span class="kc">False</span>
        <span class="k">return</span> <span class="n">ob</span><span class="p">,</span> <span class="n">reward</span><span class="p">,</span> <span class="n">done</span><span class="p">,</span> <span class="nb">dict</span><span class="p">(</span><span class="n">reward_run</span><span class="o">=</span><span class="n">reward_run</span><span class="p">,</span> <span class="n">reward_ctrl</span><span class="o">=</span><span class="n">reward_ctrl</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_get_obs</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="k">return</span> <span class="n">np</span><span class="o">.</span><span class="kp">concatenate</span><span class="p">(</span>
            <span class="p">[</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">qpos</span><span class="o">.</span><span class="kp">flat</span><span class="p">[</span><span class="mi">1</span><span class="p">:],</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">sim</span><span class="o">.</span><span class="n">data</span><span class="o">.</span><span class="n">qvel</span><span class="o">.</span><span class="kp">flat</span><span class="p">,</span>
            <span class="p">]</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">reset_model</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="n">qpos</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_qpos</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">np_random</span><span class="o">.</span><span class="kp">uniform</span><span class="p">(</span>
            <span class="n">low</span><span class="o">=-</span><span class="mf">0.1</span><span class="p">,</span> <span class="n">high</span><span class="o">=</span><span class="mf">0.1</span><span class="p">,</span> <span class="kp">size</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nq</span>
        <span class="p">)</span>
        <span class="n">qvel</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">init_qvel</span> <span class="o">+</span> <span class="bp">self</span><span class="o">.</span><span class="n">np_random</span><span class="o">.</span><span class="kp">standard_normal</span><span class="p">(</span><span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">nv</span><span class="p">)</span> <span class="o">*</span> <span class="mf">0.1</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">set_state</span><span class="p">(</span><span class="n">qpos</span><span class="p">,</span> <span class="n">qvel</span><span class="p">)</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_obs</span><span class="p">()</span>

    <span class="k">def</span> <span class="nf">viewer_setup</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">viewer</span><span class="o">.</span><span class="n">cam</span><span class="o">.</span><span class="n">distance</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">model</span><span class="o">.</span><span class="n">stat</span><span class="o">.</span><span class="n">extent</span> <span class="o">*</span> <span class="mf">0.5</span>
</code></pre></div>
<p>The video of this agent in the environment is shown below.</p>
<p>https://user-images.githubusercontent.com/62206142/148566163-089a2a3c-4361-4997-b956-d4e790cf1cbd.mp4</p>
<div id="ProblemwithTD"></div>
<h2>Problem with TD</h2>
<p>All we want is to find the best policy that suits us. Although TD agent finds the value of each state (A value that converges to the real value during the time), it cannot find the best policy because for finding that and doing one-step expectimax, $T$ and $R$ functions are needed. However, in RL, they are not available. Therefore, a new method is required, called <strong>Q-Learning</strong>.</p>
<div id="Conclusion"></div>
<h1>Summery and Conclusion</h1>
<div id="SummaryofDiscussedRLMethods"></div>
<p>In this lecture note, we tried to cover some topics of RL. First, we talked about RL itself and gave the definition. Then, we mentioned various types of RL and their differences. In the end, we tried to cover two methods of learning used in RL. There is a summary of these methods and usages of RL in the following.</p>
<h3>Discussed RL Methods</h3>
<h4>Direct Utility Estimation</h4>
<ul>
<li>Simple to implement</li>
<li>Each update is fast</li>
<li>Does not exploit Bellman constraints and converges slowly</li>
</ul>
<h4>Temporal Difference Learning</h4>
<ul>
<li>Update speed and implementation similar to direct estimation</li>
<li>Partially exploits Bellman constraints-adjusts state to 'agree' with the observed successor (Not <strong>all</strong> possible successors)</li>
</ul>
<h3>Why to use RL</h3>
<p>Here are prime reasons for using Reinforcement Learning:</p>
<ul>
<li>It helps you to find which situation needs an action</li>
<li>It Helps you to discover which action yields the highest reward over the longer period.</li>
<li>It provides the learning agent with a reward function.</li>
<li>It allows it to figure out the best method for obtaining large rewards.</li>
</ul>
<h3>Usage of RL</h3>
<p>Here are applications of Reinforcement Learning:</p>
<ul>
<li>Robotics for industrial automation.</li>
<li>Business strategy planning</li>
<li>Machine learning and data processing</li>
<li>It helps you to create training systems that provide custom instruction and materials according to the requirement of students.</li>
<li>Aircraft control and robot motion control</li>
</ul>
<div id="usefullinks"></div>
<h1>Useful Links</h1>
<p>[1] Learning to Run: Example of Reinforcement Learning. https://deepsense.ai/learning-to-run-an-example-of-reinforcement-learning/</p>
<p>[2] Reinforcement Learning Applicants. https://neptune.ai/blog/reinforcement-learning-applications</p>
<p>[3] What is Q-Learning. https://www.simplilearn.com/tutorials/machine-learning-tutorial/what-is-q-learning</p>
<p>[4] Reinforcement Learning and Python. https://www.youtube.com/watch?v=-daMfdwpmAg </p>
<div id="resources"></div>
<h1>References</h1>
<p>[1] Passive Reinforcement Learning. https://kcir.pwr.edu.pl/~witold/ai/mle_rl_h.pdf (visited: 2/1/2022)</p>
<p>[2] Active vs Passive Learning. Shweta Bhatt. https://towardsdatascience.com/explaining-reinforcement-learning-active-vs-passive-a389f41e7195 (visited: 2/1/2022)</p>
<p>[3] Active and Passive Learning. Philipp Koehn. https://www.cs.jhu.edu/~phi/ai/slides/lecture-reinforcement-learning.pdf (visited: 25/12/2021)</p>
<p>[4] Model-Based vs. Model-Free RL. Russell and Norvig. https://web.engr.oregonstate.edu/~xfern/classes/cs434/slides/RL-1.pdf (visited: 6/1/2022)</p>
<p>[5]Online vs Offline Learning. Banghua Zhu, Cong Ma, Jiantao Jiao, Paria Rashidinejad. https://congma1028.github.io/Publication/OfflineRL/OfflineRL.pdf (visited: 7/1/2022)</p>
<p>[6]Direct Utility Estimation. Oregon State University. https://web.engr.oregonstate.edu/~xfern/classes/cs434/slides/RL-1.pdf (visited: 4/1/2022)</p>
<p>[7]Direct Utility Estimation. Carnegie Mellon University. https://www.cs.cmu.edu/~arielpro/15381f16/c_slides/781f16-12.pdf (visited: 5/1/2022)</p>
<p>[8]Example of Direct Utility Estimation. Shweta Bhat. https://towardsdatascience.com/explaining-reinforcement-learning-active-vs-passive-a389f41e7195 (visited: 5/1/2022)</p>
<p>[9] Temporal Difference Learning. Andrew Barto. http://www.scholarpedia.org/article/Temporal_difference_learning (visited: 1/1/2022)</p>
<p>[10] Temporal Difference Learning. Andre Violante. https://medium.com/@violante.andre/simple-reinforcement-learning-temporal-difference-learning-e883ea0d65b0 (visited: 1/1/2022)</p>
<p>[11] Temporal Difference Learning. Viet Hoang Tran Duong. https://towardsdatascience.com/intro-to-reinforcement-learning-temporal-difference-learning-sarsa-vs-q-learning-8b4184bb4978 (visited: 3/1/2022)</p>
<p>[12] Temporal Difference Learning. Henry AI Labs. https://www.youtube.com/watch?v=L64E_NTZJ_0 (visited: 27/12/2021)</p>
<p>[13] Sutton, Richard. Reinforcement Learning: An Introduction. London : The MIT Press (visited: 6/1/2022)</p>
<p>[14] HalfCheetah-v2. James L. https://www.youtube.com/watch?v=TpWXyauJ3M8 (visited: 5/1/2022)</p>
<p>[15] HalfCheetah-Code. https://github.com/openai/gym/blob/master/gym/envs/mujoco/half_cheetah.py (visited: 5/1/2022)</p>